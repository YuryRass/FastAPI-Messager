# Описание системы

Приложение **FastAPI-Messager** представляет собой простой чат между пользователем и микросервисом, в котором микросервис переворачивает сообщение пользователя. При этом если в конце сообщения написать `!pow` либо `!rpc`, то сообщение в чат должно быть отправлено только после доказательства работы (сложность 24 бита, алгоритм [PoW](https://academy.binance.com/ru/articles/proof-of-work-explained))

**FastAPI-Messager** состоит из двух контуров: `внешний` и `внутренний`, взаимодействующих между собой посредством очереди, организованной с использованием RabbitMQ.

![](readme_images/shema.jpg)

## Внешний контур
Во `внешнем` контуре запуcкается веб-приложение, написанное на FastAPI и реализующее множественную отправку сообщений подключенным клиентам с помощью веб-сокетов. Веб-интерфейс запущенного приложения представлен на рисунке ниже (для отображения необходимо перейти по адресу: http://localhost:8000/pages/chat)

![](readme_images/web-interface.png)

Отправка сообщений между клиентами и сервером осуществляется с использованием именнованных каналов, которые реализует OpenSource-библиотека [`channel-box`](https://github.com/Sobolev5/channel-box)

В фоновом режиме раз в минуту на сервер также приходит сообщение `Hello world!` от **CronTab** посредством библиотеки [aiocron](https://github.com/gawel/aiocron)

Помимо веб-сокетного взаимодействия, сообщения также попадают и берутся из очереди, которую реализует брокер сообщений `RabbitMQ`.

> Зависимости системы: FastAPI, Jinja2, aiocron, channel-box, aiormq, pydantic, pydantic-settings

## Внутренний контур
Внутренний контур состоит из двух микросервисов: `internal__messager` и `internal__worker`

В блоке `internal__messager` происходит переворачивание сообщения и его отправка обратно в очередь для попадания во внешний контур.

Если в `internal__messager`попадает сообщение, в конце которого имеется значение `!pow` либо `!rpc`, то сообщение отправляется в контейнер `internal__worker`, где выполняется доказательство работы с использованием алгоритма [PoW (Proof of Work)](https://academy.binance.com/ru/articles/proof-of-work-explained)

После выполнения алгоритма PoW (со сложностью 24 бита) происходит отправка вычисленного хеш-значения в контейнер `internal__messager`, а из него - в `external__main`.

После отработки алгоритма `PoW` ответ для клиента во внешнем контуре выглядет следующим образом:


Разница между двумя значениями `!pow` и `!rpc` заключается в том, что при использовании `!rpc` применяется паттерн [Remote Procedure Called](https://github.com/mosquito/aiormq?tab=readme-ov-file#remote-procedure-call-rpc) поверх брокера сообщений RabbitMQ

> Зависимости системы: FastAPI channel-box, aiormq, pydantic, pydantic-settings

# Стартовая конфигурация системы
Перед запуском приложения убедитесь в наличии в
директории с проектом файла ".env", хранящего следующие настройки:

* **RABBITMQ_DEFAULT_USER** = rabbitmq
  > имя пользователя в RabbitMQ
* **RABBITMQ_DEFAULT_PASS** = rabbitmq
  > пароль в RabbitMQ
* **AMQP_URI** = amqp://rabbitmq:rabbitmq@rabbitmq/
  > полный адрес для подключения к брокеру
* **UNIQUE_PREFIX** = yurii
  > уникальный префикс для именования очередей

# Установка и запуск

Скопируйте репозиторий, используя следующую команду:

`git clone https://github.com/YuryRass/FastAPI-Messager.git`

После чего перейдите в каталог с проектом:

`cd FastAPI-Messager`

Для создания и запуска микросервисной системы выполните команду:

`docker-compose up --build`

Для запуска системы в фонов режиме добавьте флаг `-d`

`docker-compose up --build -d`